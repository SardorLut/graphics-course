#version 430
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform uniform_params{
  uint resolution_x;
  uint resolution_y;
} screen_parameters;

const float iTime = 1.0f;

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    vec3 n = vec3(
        length(p + e.xyy) - length(p - e.xyy),
        length(p + e.yxy) - length(p - e.yxy),
        length(p + e.yyx) - length(p - e.yyx)
    );
    return normalize(n);
}

float torus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sphere(vec3 p, float r) {
    return length(p) - r;
}

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float map(vec3 p) {
    float d = 1000.0; // большое начальное значение
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            vec3 torusPos = vec3(float(i) * 3.0, 0.0, float(j) * 3.0);
            
            float time = iTime * 2.0 + float(i * j);
            float bounce = abs(sin(time)) * 1.5;
            vec3 spherePos = torusPos + vec3(0.0, bounce, 0.0);
            
            float dTorus = torus(p - torusPos, vec2(1.0, 0.3));
            float dSphere = sphere(p - spherePos, 0.3);
            
            // Объединяем тор и шар
            d = opUnion(d, opUnion(dTorus, dSphere));
        }
    }
    
    return d;
}

vec3 lighting(vec3 p, vec3 normal, vec3 lightPos) {
    vec3 lightDir = normalize(lightPos - p);
    float diff = max(dot(normal, lightDir), 0.0);
    return vec3(1.0, 0.8, 0.6) * diff;
}

float raymarch(vec3 ro, vec3 rd) {
    float dist = 0.0;
    float d;
    for (int i = 0; i < 100; i++) {
        vec3 p = ro + rd * dist;
        d = map(p);
        if (d < 0.001) break;
        dist += d;
        if (dist > 50.0) break;
    }
    return dist;
}

void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

  vec2 iResolution = vec2(screen_parameters.resolution_x, screen_parameters.resolution_y);
  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;

  float camTime = iTime * 0.5;
  vec3 ro = vec3(7.0 * sin(camTime), 3.0 + sin(camTime * 0.5), 7.0 * cos(camTime));
  vec3 lookAt = vec3(0.0, 0.0, 0.0);
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, forward);
  vec3 rd = normalize(forward + uv.x * right + uv.y * up);
    
  float dist = raymarch(ro, rd);
    
  vec3 color = vec3(0.0);
    
  if (dist < 50.0) {
      vec3 p = ro + rd * dist;
      vec3 normal = calcNormal(p);
        
      vec3 lightPos = ro;
      vec3 lightColor = lighting(p, normal, lightPos);
        
      color = lightColor;
        
      color *= exp(-0.02 * dist);
  }
  if (fragCoord.x < iResolution.x && fragCoord.y < iResolution.y)
    imageStore(resultImage, fragCoord, vec4(color, 1));
}
